# This is the main configuration file for the application.
# ~~~~~

# Secret key
# ~~~~~
# The secret key is used to secure cryptographics functions.
# If you deploy your application to several instances be sure to use the same key!
play.crypto.secret="changeme"

# The application languages
# ~~~~~
play.i18n.langs=["en"]

# Registers the request handler
# ~~~~~
play.http.requestHandler = "play.api.http.DefaultHttpRequestHandler"

# Registers the filters
# ~~~~~
play.http.filters = "utils.Filters"

# The application DI modules
# ~~~~~
play.modules.enabled += "modules.BaseModule"
play.modules.enabled += "modules.JobModule"
play.modules.enabled += "modules.SilhouetteModule"
play.modules.enabled += "play.api.libs.mailer.MailerModule"
play.modules.enabled += "modules.ServiceModule"
play.modules.enabled += "play.modules.reactivemongo.ReactiveMongoModule"

# Database config
neo4j.url = "bolt://localhost:7687"
neo4j.username = "neo4j"
neo4j.password = "test"
mongodb.uri = "mongodb://localhost:27017/demodb"

play.modules.disabled += "com.mohiva.play.silhouette.api.actions.SecuredErrorHandlerModule"
play.modules.disabled += "com.mohiva.play.silhouette.api.actions.UnsecuredErrorHandlerModule"

# Akka config
akka {
  loglevel = "DEBUG"
  jvm-exit-on-fatal-error=off

  # Auth token cleaner
  #quartz.schedules.AuthTokenCleaner {
  #  expression = "0 0 */1 * * ?"
  #  timezone = "UTC"
  #  description = "cleanup the auth tokens on every hour"
  #}
}

# Play mailer
play.mailer {
  host = "smtp.sendgrid.net"
  port = 587
  tls = true
  user = ""
  user = ${?SENDGRID_USERNAME}
  password = ""
  password = ${?SENDGRID_PASSWORD}
}

unique-prio-mailbox{
  mailbox-type = "jobs.UniquePriorityMailbox"
}
akka.actor.mailbox.requirements {
  "jobs.MyPrioQueueSemantics" = unique-prio-mailbox
}

# Security Filter Configuration - Content Security Policy
play.filters.headers {
  contentSecurityPolicy = "default-src 'self';"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" img-src 'self' *.akamaihd.net secure.gravatar.com;"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" style-src 'self' 'unsafe-inline' cdnjs.cloudflare.com maxcdn.bootstrapcdn.com cdn.jsdelivr.net fonts.googleapis.com use.fontawesome.com;"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" font-src 'self' fonts.gstatic.com fonts.googleapis.com cdnjs.cloudflare.com use.fontawesome.com;"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" script-src 'self' clef.io cdnjs.cloudflare.com use.fontawesome.com;"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" connect-src 'self' twitter.com *.xing.com;"
  contentSecurityPolicy = ${play.filters.headers.contentSecurityPolicy}" frame-src clef.io;"
}

steam.key="changeme"

silhouette {

  # Authenticator settings
  authenticator.cookieName="authenticator"
  authenticator.cookiePath="/"
  authenticator.secureCookie=false // Disabled for testing on localhost without SSL, otherwise cookie couldn't be set
  authenticator.httpOnlyCookie=true
  authenticator.useFingerprinting=true
  authenticator.authenticatorIdleTimeout=30 minutes
  authenticator.authenticatorExpiry=12 hours

  authenticator.rememberMe.cookieMaxAge=30 days
  authenticator.rememberMe.authenticatorIdleTimeout=5 days
  authenticator.rememberMe.authenticatorExpiry=30 days

  authenticator.cookie.signer.key = "[changeme]" // A unique encryption key
  authenticator.crypter.key = "[changeme]" // A unique encryption key

  # OAuth1 token secret provider settings
  oauth1TokenSecretProvider.cookieName="OAuth1TokenSecret"
  oauth1TokenSecretProvider.cookiePath="/"
  oauth1TokenSecretProvider.secureCookie=false // Disabled for testing on localhost without SSL, otherwise cookie couldn't be set
  oauth1TokenSecretProvider.httpOnlyCookie=true
  oauth1TokenSecretProvider.expirationTime=5 minutes

  oauth1TokenSecretProvider.cookie.signer.key = "[changeme]" // A unique encryption key
  oauth1TokenSecretProvider.crypter.key = "[changeme]" // A unique encryption key

  # OAuth2 state provider settings
  oauth2StateProvider.cookieName="OAuth2State"
  oauth2StateProvider.cookiePath="/"
  oauth2StateProvider.secureCookie=false // Disabled for testing on localhost without SSL, otherwise cookie couldn't be set
  oauth2StateProvider.httpOnlyCookie=true
  oauth2StateProvider.expirationTime=5 minutes

  oauth2StateProvider.cookie.signer.key = "[changeme]" // A unique encryption key

  # Facebook provider
  facebook.authorizationURL="https://graph.facebook.com/v2.3/oauth/authorize"
  facebook.accessTokenURL="https://graph.facebook.com/v2.3/oauth/access_token"
  facebook.redirectURL="http://localhost:9000/authenticate/facebook"
  facebook.clientID=""
  facebook.clientID=${?FACEBOOK_CLIENT_ID}
  facebook.clientSecret=""
  facebook.clientSecret=${?FACEBOOK_CLIENT_SECRET}
  facebook.scope="email"

  # Google provider
  google.authorizationURL="https://accounts.google.com/o/oauth2/auth"
  google.accessTokenURL="https://accounts.google.com/o/oauth2/token"
  google.redirectURL="http://localhost:9000/authenticate/google"
  google.clientID=""
  google.clientID=${?GOOGLE_CLIENT_ID}
  google.clientSecret=""
  google.clientSecret=${?GOOGLE_CLIENT_SECRET}
  google.scope="profile email"

  # VK provider
  vk.authorizationURL="http://oauth.vk.com/authorize"
  vk.accessTokenURL="https://oauth.vk.com/access_token"
  vk.redirectURL="http://localhost:9000/authenticate/vk"
  vk.clientID=""
  vk.clientID=${?VK_CLIENT_ID}
  vk.clientSecret=""
  vk.clientSecret=${?VK_CLIENT_SECRET}
  vk.scope="email"

  # Clef provider
  clef.accessTokenURL="https://clef.io/api/v1/authorize"
  clef.redirectURL="http://localhost:9000/authenticate/clef"
  clef.clientID=""
  clef.clientID=${?CLEF_CLIENT_ID}
  clef.clientSecret=""
  clef.clientSecret=${?CLEF_CLIENT_SECRET}

  # Twitter provider
  twitter.requestTokenURL="https://twitter.com/oauth/request_token"
  twitter.accessTokenURL="https://twitter.com/oauth/access_token"
  twitter.authorizationURL="https://twitter.com/oauth/authenticate"
  twitter.callbackURL="http://localhost:9000/authenticate/twitter"
  twitter.consumerKey=""
  twitter.consumerKey=${?TWITTER_CONSUMER_KEY}
  twitter.consumerSecret=""
  twitter.consumerSecret=${?TWITTER_CONSUMER_SECRET}

  # Xing provider
  xing.requestTokenURL="https://api.xing.com/v1/request_token"
  xing.accessTokenURL="https://api.xing.com/v1/access_token"
  xing.authorizationURL="https://api.xing.com/v1/authorize"
  xing.callbackURL="http://localhost:9000/authenticate/xing"
  xing.consumerKey=""
  xing.consumerKey=${?XING_CONSUMER_KEY}
  xing.consumerSecret=""
  xing.consumerSecret=${?XING_CONSUMER_SECRET}

  # Yahoo provider
  yahoo.providerURL="https://me.yahoo.com/"
  yahoo.callbackURL="http://localhost:9000/authenticate/yahoo"
  yahoo.axRequired={
    "fullname": "http://axschema.org/namePerson",
    "email": "http://axschema.org/contact/email",
    "image": "http://axschema.org/media/image/default"
  }
  yahoo.realm="http://localhost:9000"

  # Steam provider
  steam.providerURL="https://steamcommunity.com/openid"
  steam.callbackURL="http://192.168.0.169:9000/authenticate/steam"
  steam.axRequired={
    "fullname": "http://axschema.org/namePerson",
    "email": "http://axschema.org/contact/email",
    "image": "http://axschema.org/media/image/default"
  }
  steam.realm="http://192.168.0.169:9000"
}


#include "application.conf"

play.crypto.secret=${?PLAY_APP_SECRET}

# Allow all proxies for Heroku so that X-Forwarded headers can be read by Play
# ~~~~~
play.http.forwarded.trustedProxies=["0.0.0.0/0", "::/0"]

silhouette {

  # Authenticator settings
  authenticator.cookieDomain=${MAIN_URL}
  authenticator.secureCookie=true

  # OAuth1 token secret provider settings
  oauth1TokenSecretProvider.cookieDomain=${MAIN_URL}
  oauth1TokenSecretProvider.secureCookie=true

  # OAuth2 state provider settings
  oauth2StateProvider.cookieDomain=${MAIN_URL}
  oauth2StateProvider.secureCookie=true

  # Steam provider
  steam.callbackURL=${MAIN_URL}authenticate/steam
  steam.realm=${MAIN_URL}
}

steam.key=${?STEAM_API_KEY}

# Database config
neo4j.url = ${?GRAPHENEDB_BOLT_URL}
neo4j.username = ${?GRAPHENEDB_BOLT_USER}
neo4j.password = ${?GRAPHENEDB_BOLT_PASSWORD}
mongodb.uri = ${?MONGODB_URI}